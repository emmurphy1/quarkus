////
This guide is maintained in the main {ProductName} repository
and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
////
= Using simplified Hibernate ORM with Panache


include::./attributes.adoc[]
:config-file: application.properties
:COMM:


As a Java developer, you can use Hibernate ORM with Panache to simplify persistence with your {ProductName} applications.

.Prerequisites
You have a {ProductName} Maven project configured with a Java database connectivy (JDBC) datasource and Hibernate ORM.

ifdef::ENT[]
* For information about creating a {ProductName} Maven project, see https://access.redhat.com/documentation/en-us///red_hat_build_of_quarkus/{ProductVersion}/html-single/creating_quarkus_applications_with_apache_maven/[_Creating Quarkus applications with Apache Maven_].
endif::ENT[]

ifdef::COMM[]
* For information about creating a {ProductName} Maven project, see https://quarkus.io/guides/maven-tooling[_Quarkus - Building Applications with Maven_].
endif::COMM[]

* For information about configuring your {ProductName} Maven project with a JDBC datasource, see https://quarkus.io/guides/datasource[_Quarkus - Configuring your datasources_].
* For information about configuring your {ProductName} Maven project Hibernate ORM, see https://quarkus.io/guides/hibernate-orm[_Quarkus - Quarkus - Hibernate ORM and JPA_].

For an example of a completed {ProductName} Maven project that uses the Panache extension, see the https://github.com/quarkusio/quarkus-quickstarts/tree/master/hibernate-orm-panache-quickstart[Hibernate ORM Panache Quickstart].

== Hibernate ORM

//adapted from https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html. Module will be reused in Hibernate ORM story.

Coupling Java object-oriented software projects with relational databases for data persistence can be cumbersome and time-consuming. Development costs are significantly higher due to a paradigm mismatch between how data is represented in objects versus relational databases. Hibernate is an Object/Relational Mapping (ORM) solution for Java environments that facilitates mapping data to and from an object model representation to a relational data model representation. It is an implementation of the Java Persistence API (JPA).

Hibernate not only takes care of the mapping from Java classes to database tables and from Java data types to SQL data types, but also provides data query and retrieval facilities. It can significantly reduce development time otherwise spent with manual data handling in SQL and Java database connectivity (JDBC). Hibernateâ€™s design goal is to relieve you of most common data persistence-related programming tasks by eliminating the need for manual data processing using SQL and JDBC.

The JPA `@entity` annotation is at the heart of Hibernate ORM. When applied to a Java class, it maps the class to a specific database table. The fields in the class map to database columns. Each instance of the class represents a database row.

== Hibernate ORM with the {ProductName} Panache JPA extension

Hibernate ORM is the most widely used JPA implementation. It provides all of the features of an ORM. However, for a simple implementation with the most common data mappings you can use the {ProductName} Panache JPA extension to write more concise code.

The Hibernate ORM with Panache extension contains the following classes:

* `PanacheEntity`
* `PanacheEntityBase`
* `PanacheQuery`
* `PanacheRepository`
* `PanacheRepositoryBase`
* `PanacheEntity`

The {ProductName} Panache JPA extension eliminates the following Hiberante ORM issues:

* *Duplicate ID logic*
+
You use the `PanacheEntity` class to create entities. Because the ID is defined automatically in the `PanacheEntity` class, you do not need to define it in your `PanacheEntity` instance. However, you can specify your own ID in your instance if you prefer.  If you require a custom ID strategy, you can extend the `PanacheEntityBase` class instead.

* *Useless `getter` and `setter` functions*
+
Because Java does not support properties, when you write Java code you must create fields and then generate `getter` and `setter` functions for those fields, even if all you need to do is read or write to the field. With Panache, if you define a field as a public field and then read or write to that field, Panache generates the required `getter` and `setter` functions. In addition, you can write other accessors as required.
* *Entity definitions split from operations*
+
In the traditional Java EE model, you put the the entity definition in one class, the model, and the operations performed on the model in another class, the data access object (DAO) or repository. The Panache active record method enables you to create the entity definition and the repository in the same class.

* *Verbose Hibernate queries*
+
Panache provides Hibernate Query Language (HQL) shortcuts to simplify your queries. You do not write parts of the query that you do not need.




=== Using the Panache active record pattern


When you use Hiberate ORM, you must create two classes that separate the state and its operations even though you would never do that for regular Java objects where state and methods are in the same class. In addition to requiring two classes, Hibernate ORM requires you to  inject the repository where you need to perform entity operations, which breaks your edit flow and requires you to get out of the code that you are  writing to set up an injection point before coming back to use it.

You can use the Panache active record pattern with the `PanacheEntity` class to keep the model and the repository together.

.Procedure.

. Add the Panache JPA extension dependency to your {ProductName} project `pom.xml` file:
+
[source,java]
----
<dependencies>
    <dependency>
        <groupId>io.quarkus</groupId>
        <artifactId>quarkus-hibernate-orm-panache</artifactId>
    </dependency>
----

+
. To define an entity, create a class that extends the `PanacheEntity` class, annotate it with `@Entity`, and add your
columns as public fields. The following example creates and annotates the `Person` class:
+
[source,java]
----
@Entity
public class Person extends PanacheEntity {
    public String name;
    public LocalDate birth;
    public Status status;
}
----
+
. Optional: To specify that a field not persist, use the `@Transient` annotation. The following example annotates the `status` field with `@Transient`.
+
[source,java]
----
@Entity
public class Person extends PanacheEntity {
    public String name;
    public LocalDate birth;

    @Transient
    public Status status;
}
----
. Add any additional accessors. The following example adds an accessor that returns `name` as uppercase in the model and an accessor that stores all names in lowercase in the database.
//COMMENT: Is there a different between 'in the model' and 'in the database'?
+
[source,java]
----
@Entity
public class Person extends PanacheEntity {
    public String name;
    public LocalDate birth;

    @Transient
    public Status status;
}
    public String getName(){
        return name.toUpperCase();
    }
    public void setName(String name){
        this.name = name.toLowerCase();
    }
}
----
+
In this example, when users access `person.name` they call the `getName()` accessor and when they call the `setName()` they set the value of `name`. This enables correct encapsulation at runtime because all field calls are replaced with the corresponding `getter` and `setter` calls.
. Add custom queries to your entities as static methods inside the entities themselves so queries are co-located with the object they operate on. The following example adds three custom queries, `findByName`, `findAlive`, and `deleteStefs`:
+
[source,java]
----
@Entity
public class Person extends PanacheEntity {
    public String name;
    public LocalDate birth;
    public Status status;

    public static Person findByName(String name){
        return find("name", name).firstResult();
    }

    public static List<Person> findAlive(){
        return list("status", Status.Alive);
    }

    public static void deleteStefs(){
        delete("name", "Stef");
    }
}
----


=== Using the Panache repository pattern
Panache enables you to create entities that contain the model and repository in a single class. However, if you prefer to create a separate class for the model and a separate class for the repository and still have the other benefits of Panache, for example having the `getters` and `setter` automatically generate, you can use the repository pattern.

.Procedure.


. Add the Panache JPA extension dependency to your {ProductName} project `pom.xml` file:
+
[source,java]
----
<dependencies>
    <dependency>
        <groupId>io.quarkus</groupId>
        <artifactId>quarkus-hibernate-orm-panache</artifactId>
    </dependency>
----

. Define entities as JPA entities. The following example defines the `Person` class as a JPA entity.
+
[source,java]
----
@Entity
public class Person {
    @Id @GeneratedValue private Long id;
    private String name;
    private LocalDate birth;
    private Status status;

    public Long getId(){
        return id;
    }
    public void setId(Long id){
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public LocalDate getBirth() {
        return birth;
    }
    public void setBirth(LocalDate birth) {
        this.birth = birth;
    }
    public Status getStatus() {
        return status;
    }
    public void setStatus(Status status) {
        this.status = status;
    }
}
----
. Define your repository and add instance methods. The following example defines the `PersonRepository` :
+
[source,java]
----
@ApplicationScoped
public class PersonRepository implements PanacheRepository<Person> {

   public Person findByName(String name){
       return find("name", name).firstResult();
   }

   public List<Person> findAlive(){
       return list("status", Status.Alive);
   }

   public void deleteStefs(){
       delete("name", "Stef");
  }
}
----

+
. Add the following code to the REST endpoint where you want to use entity operations so that the operations that are defined in `PanacheEntityBase` are available:
+
[source,java]
----
@Inject
PersonRepository personRepository;

@GET
public long count(){
    return personRepository.count();
}
----

=== Pananche common operations
This section lists common operations that you can use with your entity or repository. The active record pattern examples use a `Person` entity created from the `PanacheEntity` class. The repository pattern examples use a regular JPA `Person` entity and the `PersonRepository` created from the
`PanacheRepository` class.

* Create a record (active record pattern and repository pattern):
+
[source,java]
----
Person person = new Person();
person.name = "Stef";
person.birth = LocalDate.of(1910, Month.FEBRUARY, 1);
person.status = Status.Alive;
----

* Persist an entity:
** Active record pattern:
+
[source,java]
----
person.persist(person);
----

** Repository pattern:
+
[source,java]
----
personRepository.persist(person);
----
+
NOTE: After an entity is persisted, you do not need to explicitly save your entity. All changes are automatically persisted on transaction commit.

* Verify that an entity is persisted:
** Active record pattern:
+
[source,java]
----
if(person.isPersistent(person))
----
** Repository pattern:
+
[source,java]
----
if(personRepository.isPersistent(person))
----

* Delete an entity:
** Active record pattern:
+
[source,java]
----
person.delete(person);
----

** Repository pattern:
+
[source,java]
----
personRepository.delete(person);
----

* Retrieve a list of all `Person` entities:
** Active record pattern:
+
[source,java]
----
List<Person> allPersons = person.listAll();
----
** Repository pattern:
+
[source,java]
----
List<Person> allPersons = personRepository.listAll();
----
* Find a specific person by ID:
** Active record pattern:
+
[source,java]
----
person = person.findById(personId);
----
** Repository pattern:
+
[source,java]
----
person = personRepository.findById(personId);
----

* Find a specific person by ID using the `Optional` class:
** Active record pattern:
+
[source,java]
----
Optional<Person> optional = person.findByIdOptional(personId);
person = optional.orElseThrow(() -> new NotFoundException());
----

** Repository pattern:
+
[source,java]
----
Optional<Person> optional = personRepository.findByIdOptional(personId);
person = optional.orElseThrow(() -> new NotFoundException());
----

* Find all living persons:
** Active record pattern:
+
[source,java]
----
List<Person> livingPersons = person.list("status", Status.Alive);
----
** Repository pattern:
+
[source,java]
----
List<Person> livingPersons = personRepository.list("status", Status.Alive);
----

* Count all persons:
** Active record pattern:
+
[source,java]
----
long countAll = person.count();
----
** Repository pattern:
+
[source,java]
----
long countAll = personRepository.count();
----

* Count all living persons:
** Active record pattern:
+
[source,java]
----
long countAlive = person.count("status", Status.Alive);
----
** Repository pattern:
+
[source,java]
----
long countAlive = personRepository.count("status", Status.Alive);
----

* Delete all living persons:
** Active record pattern:
+
[source,java]
----
person.delete("status", Status.Alive);
----
** Repository pattern:
+
[source,java]
----
personRepository.delete("status", Status.Alive);
----


* Delete all persons:
** Active record pattern:
+
[source,java]
----
person.deleteAll();
----
** Repository pattern:
+
[source,java]
----
personRepository.deleteAll();
----

* Delete by ID:
** Active record pattern:
+
[source,java]
----
boolean deleted = person.deleteById(personId);
----
** repository pattern:
+
[source,java]
----
boolean deleted = personRepository.deleteById(personId);
----

* Set the name of all living persons to Mortal:
** Active record pattern:
+
[source,java]
----
person.update("name = 'Mortal' where status = ?1", Status.Alive);
----
** Repository pattern:
+
[source,java]
----
personRepository.update("name = 'Mortal' where status = ?1", Status.Alive);
----

All `List` methods have equivalent `stream` methods, which requires a transaction to work as shown in the following example:

[source,java]
----
Stream<Person> persons = personRepository.streamAll();
List<String> namesButEmmanuels = persons
    .map(p -> p.name.toLowerCase() )
    .filter( n -> ! "emmanuel".equals(n) )
    .collect(Collectors.toList());
----

== Hibernate ORM with Panache queries

Hibernate Query Language (HQL) is a query language similar to Structured Query Language (SQL). However, HQL works with persistent objects and properties instead of tables and columns. For more information about HQL, see the "HQL and JPQL" section of the xref:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html[_Hibernate ORM User Guide_].

=== PanacheQuery entity

The `PanacheQuery` entity  abstracts the use of paging, getting the number of results, and operating on `List` or `Stream` methods. You can use the `PanacheQuery` entity  for paging and range-based queries.


Only use `List` and `Stream` methods if your table contains small data sets. For large data
sets, use the `Find` method equivalents, which return a `PanacheQuery` on which you can perform paging.

[WARNING]
====
You cannot mix ranges and pages. If your query uses a range, any methods that depend on having a current page throw an `UnsupportedOperationException` exception. To switch back to paging, use `page(Page)` or `page(int, int)`.
====

.Additional resources
* For a complete list of  `PanacheQuery` methods, see the https://javadoc.io/doc/io.quarkus/quarkus-hibernate-orm-panache/latest/io/quarkus/hibernate/orm/panache/PanacheQuery.html[_PanacheQuery Class_] page.

==== Examples of queries that use paging
These examples show how you can use paging in your Panache queries. The active record pattern examples use a `Person` entity created from the `PanacheEntity` class. The repository pattern examples use a regular JPA `Person` entity and the `PersonRepository` created from the
`PanacheRepository` class.



* Create a query for all living persons:
** Active record pattern:
+
[source,java]
----
PanacheQuery<Person> livingPersons = Person.find("status", Status.Alive);
----
** Repository pattern:
+
[source,java]
----
PanacheQuery<PersonRepository> livingPersons = Person.find("status", Status.Alive);
----


* Make pages have 25 entries per page:
+
[source,java]
----
livingPersons.page(Page.ofSize(25));
----


* Retrieve the first page:
** Active record pattern:
+
[source,java]
----
List<Person> firstPage = livingPersons.list();
----
** Repository pattern:
+
[source,java]
----
List<Person.Repository> firstPage = livingPersons.list();
----

* Retrieve the second page:
** Active record pattern:
+
[source,java]
----
List<Person> secondPage = livingPersons.nextPage().list();
----
** Repository pattern:
+
[source,java]
----
List<PersonRepository> secondPage = livingPersons.nextPage().list();
----

* Retrieve page 7:
** Active record pattern:
+
[source,java]
----
List<Person> page7 = livingPersons.page(Page.of(7, 25)).list();
----
** Repository pattern:
+
[source,java]
----
List<PersonRepository> page7 = livingPersons.page(Page.of(7, 25)).list();
----

* Retrieve the number of pages:
+
[source,java]
----
int numberOfPages = livingPersons.pageCount();
----

* Retrieve the total number of entities returned by this query without paging:
[source,java]
----
int count = livingPersons.count();
----

* Chain methods together:
** Active record pattern:
+
[source,java]
----
return Person.find("status", Status.Alive)
   .page(Page.ofSize(25))
   .nextPage()
   .stream()
----
** Repository pattern:
+
[source,java]
----
return PersonRepository.find("status", Status.Alive)
   .page(Page.ofSize(25))
   .nextPage()
   .stream()
----

==== Examples of queries that use a range of values
These examples show how you can use a range of values in your Panache queries. The active record pattern examples use a `Person` entity created from the `PanacheEntity` class. The repository pattern examples use a regular JPA `Person` entity and the `PersonRepository` created from the
`PanacheRepository` class.


* Create a query for all living persons:
** Active record pattern:
+
[source,java]
----
PanacheQuery<Person> livingPersons = Person.find("status", Status.Alive);
----
** Repository pattern:
+
[source,java]
----
PanacheQuery<PersonRepository> livingPersons = Person.find("status", Status.Alive);
----

* Specify a range from index 0 to index 24 (inclusive):
+
[source,java]
----
livingPersons.range(0, 24);
----

* Specify a range called `firstRange` with the range index 0 to index 24 (inclusive):
** Active record pattern:
+
[source,java]
----
List<Person> firstRange = livingPersons.list();
----
** Repository pattern:
+
[source,java]
----
List<PersonRepository> firstRange = livingPersons.list();
----

* Specify a new range called `secondRange` with the range index 25 to index 49 (inclusive):
** Active record pattern:
+
[source,java]
----
List<Person> secondRange = livingPersons.range(25, 49).list();
----

** Repository pattern:
+
[source,java]
----
List<PersonRepository> secondRange = livingPersons.range(25, 49).list();
----


=== Simplified Hibernate ORM with Panache queries
You can use HQL to write queries for Hibernate ORM with Panache entities, as shown in the following example:

[source,java]
----
Order.find("select distinct o from Order o left join fetch o.lineItems");
Order.update("update from Person set name = 'Mortal' where status = ?", Status.Alive);
----

However, Hibernate ORM with Panache provides several HQL short cuts.

.FROM
In most cases, HQL `SELECT` statements are immediately followed by the `FROM` clause, for example `SELECT name FROM _ENTITY_NAME_`, where `_ENTITY_NAME_` is the name of a Java entity. However, if you do not include `FROM` in your HQL `SELECT` statement, Panache adds `FROM` in the following cases:

[cols="30%,70%" options="header"]

|===
h|User entry
h|Expanded entry

|`ORDER BY`
|`FROM _ENTITY_NAME_ ORDER BY`

| A single column name and a single parameter `_SINGLE_COLUMN_NAME_`
|`FROM _ENTITY_NAME_ WHERE  _SINGLE_COLUMN_NAME_  =?`


| A query string (_QUERY_STRING_)
| `FROM _ENTITY_NAME_ WHERE  _QUERY_STRING_`


|===


.UPDATE

If you do not include `UPDATE` in your HQL `SELECT` statement, Panache adds `UPDATE` in the following cases:

[cols="30%,70%" options="header"]

|===
h|User entry
h|Expanded entry

|`FROM _ENTITY_NAME_`
|`UPDATE FROM _ENTITY_NAME_`

| `set? _SINGLE_COLUMN_NAME_`, where  `_SINGLE_COLUMN_NAME_` is a single column name and a single parameter
| `UPDATE FROM _ENTITY_NAME_ set _SINGLE_COLUMN_NAME_ =?`


| `set? _QUERY_STRING_`, where  `_QUERY_STRING_`is a query string
| `UPDATE FROM _ENTITY_NAME_ set _QUERY_STRING_`

|===

== Named queries

A named query is a statically defined query with an unchangeable query string annotated with the Hibernate ORM `@NamedQuery` annotation. With Panache, you can reference a named query from the `find` method. For a named query to work within the context of Panache, it must be defined inside of a `PanacheEntity` class or a `PanacheRepository` class or a super class of one of these classes.

.Prerequisites
* A `PanacheEntity` or a `PanacheRepository` class exists.

.Procedure

. Add the `@NamedQuery` annotation to a Panache entity.
. In the `find` method, prefix the named query with `#`.
+
The following example creates the `Person.getByName` query and uses it in the `find` method:
+
[source,java]
----
@Entity
@NamedQuery(name = "Person.getByName", query = "from Person where name = :name")
public class Person extends PanacheEntity {
    public String name;
    public LocalDate birth;
    public Status status;

    public static Person findByName(String name){
        return find("#Person.getByName", name).firstResult();
    }
}
----

=== Query parameters

You can pass query parameters by using 1-based indexing, by creating a map, or by creating an instance of the `Parameter` class.

* *1-based indexing example*:
[source,java]
----
Person.find("name = ?1 and status = ?2", "stef", Status.Alive);
----

* *Map example*:

[source,java]
----
Map<String, Object> params = new HashMap<>();
params.put("name", "stef");
params.put("status", Status.Alive);
Person.find("name = :name and status = :status", params);
----

* *`Parameters` class examples*:
** Generate a map:
+
[source,java]
----

Person.find("name = :name and status = :status",
         Parameters.with("name", "stef").and("status", Status.Alive).map());
----
** Use as-is:
+
[source,java]
----
Person.find("name = :name and status = :status",
         Parameters.with("name", "stef").and("status", Status.Alive));
----

=== Sorting

The following examples demonstrate different ways to sort.

* Methods that accept a query string also accept the following simplified query form:
+
[source,java]
----
List<Person> persons = Person.list("order by name,birth");
----

* Methods that accept a query string accept an optional `Sort` parameter, which enables you to abstract your sorting:
** Sort example 1
+
[source,java]
----
List<Person> persons = Person.list(Sort.by("name").and("birth"));
----
** Sort example 2
+

[source,java]
----
List<Person> persons = Person.list("status", Sort.by("name").and("birth"), Status.Alive);
----

The `Sort` class has many methods for adding columns and specifying sort direction.

== Transactions

Wrap methods that modify your database, for example `entity.persist()`, within a transaction. When you do this, the JPA will batch any changes that you make to you entities at the end of the transaction or before a query. This process is called a flush. It is the most efficient way to persist changes.


NOTE: If you want to check optimistic locking failures, perform object validation right away, or get immediate feedback, you can force the flush operation by calling `entity.flush()` or use `entity.persistAndFlush()` to make it a single method call. This enables you to catch any `PersistenceException` errors that occur when JPA sends changes to the database. However, this method is not efficient and transactions must still be committed.


.Procedure

To create a transaction, add the `@Transactional` annotation to your method at application entry point boundaries such as REST endpoint controllers.

The following example demonstrates the use of the flush method to allow a specific action in case of a `PersistenceException` error:
[source,java]
----
@Transactional
public void create(Parameter parameter){
    try {
        //The following code uses the persistAndFlush() shorthand method on a Panache repository to persist to the database then flush the changes:
        return parameterRepository.persistAndFlush(parameter);
    }
    catch(PersistenceException pe){
        LOG.error("Unable to create the parameter", pe);
        //The following code saves the data to disk in case of an error:
        diskPersister.save(parameter);
    }
}
----

== Panache lock management

Panache provides direct support for database locking with your entity or repository, using `findById(Object, LockModeType)` or `find().withLock(LockModeType)`. The following examples use  the active record pattern and the `Person` class. You can apply the same method to repositories.

.Locking using the `findById()` method

[source,java]
----
public class PersonEndpoint {

    @GET
    @Transactional
    public Person findByIdForUpdate(Long id){
        Person p = Person.findById(id, LockModeType.PESSIMISTIC_WRITE);
        //Perform some action.The lock will be released when the transaction ends.
        return person;
    }

}
----

.Locking in a `find()` method

[source,java]
----
public class PersonEndpoint {

    @GET
    @Transactional
    public Person findByNameForUpdate(String name){
        Person p = Person.find("name", name).withLock(LockModeType.PESSIMISTIC_WRITE).findOne();
        //Perform some action. The lock will be released when the transaction ends.
        return person;
    }

}
----

NOTE: Locks are released when the transaction ends, so the method that invokes the lock query must be annotated with the `@Transactional` annotation.

== Custom IDs

One of the advantages of Panache is that IDs are set automatically in the `PanacheEntityBase` and  `PanacheEntityRepositoryBase` classes. You can specify your own ID strategy by extending the `PanacheEntityBase` or `PanacheEntityRepositoryBase` class, depending on the entity method you are using.


.Procedure

. Create a class that extends `PanacheEntityBase`.
. Declare the ID you want as a public field. The following example extends the  `PanacheEntityBase` by creating the `Person` class.
+
[source,java]
----
@Entity
public class Person extends PanacheEntityBase {

    @Id
    @SequenceGenerator(
            name = "personSequence",
            sequenceName = "person_id_seq",
            allocationSize = 1,
            initialValue = 4)
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "personSequence")
    public Integer id;

    //...
}
----

[NOTE]
====
If you are using repositories, extend the `PanacheRepositoryBase` class instead of the `PanacheRepository` class
and specify your ID type as an extra type parameter:

[source,java]
----
@ApplicationScoped
public class PersonRepository implements PanacheRepositoryBase<Person,Integer> {
    //...
}
----
====



== Defining entities in external projects or JAR files
//Added content from https://{ProductName}.io/guides/cdi-reference#how-to-generate-a-jandex-index. This module could be shared.

Hibernate ORM with Panache relies on Java `bytecode` enhancements that are added to your entities at compile time. If you define your entities in the project where you build your {ProductName} application, the  `bytecode` enhancements are added correctly. If the entities come from external projects or JAR files, use Jandex to index your JAR file to ensure that it is treated like a {ProductName} application library. Doing this enables {ProductName} to index and enhance your entities as if they were inside the current project.

.Prerequisites
* A {ProductName} Maven project that uses the Hibernate ORM with Panache extension is available.

.Procedure
To generate the Jandex index, use one of the following methods:

* Add the following dependency to your project's `pom.xml` file:
+
[source,xml]
----
<build>
  <plugins>
    <plugin>
      <groupId>org.jboss.jandex</groupId>
      <artifactId>jandex-maven-plugin</artifactId>
      <version>1.0.7</version>
      <executions>
        <execution>
          <id>make-index</id>
          <goals>
            <goal>jandex</goal>
          </goals>
        </execution>
      </executions>
    </plugin>
  </plugins>
</build>
----

* Add `quarkus.index-dependency` entries to your `application.properties` file, where `_NAME_` is the name of the dependency,`_GROUP_ID_` is the group ID for that dependency, `_ARTIFACT_ID` is the artifact ID for that dependency, and `_CLASSIFIER_` is the dependency classifier:
+
[source,properties]
----
quarkus.index-dependency._NAME_.group-id=_GROUP_ID_
quarkus.index-dependency._NAME_.artifact-id=<_ARTIFACT-ID_
quarkus.index-dependency._NAME_.classifier=_CLASSIFIER_
----
+
NOTE: The `quarkus.index-dependency._NAME_.classifier=_CLASSIFIER_` line is optional.
+
For example, the following entries ensure that the `org.acme:acme-api` dependency is indexed:
+
[source,properties]
----
quarkus.index-dependency.acme.group-id=org.acme
quarkus.index-dependency.acme.artifact-id=acme-api
----

== Mocking

If you want to test part of your project in isolation and that part has dependencies on other objects, you need to create stand-in objects for the dependencies so you can perform a unit test. These stand-ins are called a mock objects. Mockito is a popular mocking framework.



=== Using Mokito with the active record pattern

If you are using the Panache active record pattern, you cannot use the Mockito mocking framework directly because it does not support the mocking of static methods. To use Mokito with the active record pattern, use the `quarkus-panache-mock` extension. It enables you to use Mockito to mock all provided static methods, including methods that you create. This example shows you how to use Mokito to perform various tests on the `Person` entity.

.Prerequisites
* You have a {ProductName} Maven project that uses the Panache active record pattern for persistence.

.Procedure

. Add the `quarkus-panache-mock` extension dependency to your project's  `pom.xml` file:
+
[source,xml]
----
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-panache-mock</artifactId>
    <scope>test</scope>
</dependency>
----
. Create the `Person` entity:
+
[source,java]
----
@Entity
public class Person extends PanacheEntity {

    public String name;

    public static List<Person> findOrdered() {
        return find("ORDER BY name").list();
    }
}
----

. Create the following mocking test:
+
[source,java]
----
@QuarkusTest
public class PanacheFunctionalityTest {

    @Test
    public void testPanacheMocking() {
        PanacheMock.mock(Person.class);

        // Mocked classes always return a default value.
        Assertions.assertEquals(0, Person.count());

        // Specify the return value:
        Mockito.when(Person.count()).thenReturn(23l);
        Assertions.assertEquals(23, Person.count());

        // Change the return value:
        Mockito.when(Person.count()).thenReturn(42l);
        Assertions.assertEquals(42, Person.count());

        // Call the original method:
        Mockito.when(Person.count()).thenCallRealMethod();
        Assertions.assertEquals(0, Person.count());

        // Check that the method was called four times.
        PanacheMock.verify(Person.class, Mockito.times(4)).count();// <1>

        // Mock only with specific parameters:
        Person p = new Person();
        Mockito.when(Person.findById(12l)).thenReturn(p);
        Assertions.assertSame(p, Person.findById(12l));
        Assertions.assertNull(Person.findById(42l));

        // Mock throwing:
        Mockito.when(Person.findById(12l)).thenThrow(new WebApplicationException());
        Assertions.assertThrows(WebApplicationException.class, () -> Person.findById(12l));

        // Mock custom methods:
        Mockito.when(Person.findOrdered()).thenReturn(Collections.emptyList());
        Assertions.assertTrue(Person.findOrdered().isEmpty());

        PanacheMock.verify(Person.class).findOrdered();
        PanacheMock.verify(Person.class, Mockito.atLeastOnce()).findById(Mockito.any());
        PanacheMock.verifyNoMoreInteractions(Person.class);
    }
}
----

NOTE: Call your `verify` methods on `PanacheMock` rather than `Mockito`, otherwise you will not know
what mock object to pass.

=== Using Mokito with the repository pattern

If you are using the Panache repository pattern and the `quarkus-junit5-mockito` extension, you can use the Mockito mocking framework directly. This method makes mocking beans easier.

.Prerequisites
* You have a {ProductName} Maven project that uses the Panache repository pattern for persistence.

.Procedure
. Add the `quarkus-junit5-mockito` extension dependency to your projectâ€™s pom.xml file:
+
[source,java]
----
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-junit5-mockito</artifactId>
    <scope>test</scope>
</dependency>
----

. Create the `Person` entity:
+
[source,java]
----
@Entity
public class Person {

    @Id
    @GeneratedValue
    public Long id;

    public String name;
}
----

. Create the `PersonRepository` repository:
+
[source,java]
----
@ApplicationScoped
public class PersonRepository implements PanacheRepository<Person> {
    public List<Person> findOrdered() {
        return find("ORDER BY name").list();
    }
}
----

. Create the following mocking test:
+
[source,java]
----
@QuarkusTest
public class PanacheFunctionalityTest {
    @InjectMock
    PersonRepository personRepository;

    @Test
    public void testPanacheRepositoryMocking() throws Throwable {

        // Mocked classes always return a default value
        Assertions.assertEquals(0, personRepository.count());

        // Specify the return value:
        Mockito.when(personRepository.count()).thenReturn(23l);
        Assertions.assertEquals(23, personRepository.count());

        // Change the return value:
        Mockito.when(personRepository.count()).thenReturn(42l);
        Assertions.assertEquals(42, personRepository.count());

        // Call the original method:
        Mockito.when(personRepository.count()).thenCallRealMethod();
        Assertions.assertEquals(0, personRepository.count());

        // Check that we called it 4 times
        Mockito.verify(personRepository, Mockito.times(4)).count();

        // Mock only with specific parameters:
        Person p = new Person();
        Mockito.when(personRepository.findById(12l)).thenReturn(p);
        Assertions.assertSame(p, personRepository.findById(12l));
        Assertions.assertNull(personRepository.findById(42l));

        // Mock throwing:
        Mockito.when(personRepository.findById(12l)).thenThrow(new WebApplicationException());
        Assertions.assertThrows(WebApplicationException.class, () -> personRepository.findById(12l));

        Mockito.when(personRepository.findOrdered()).thenReturn(Collections.emptyList());
        Assertions.assertTrue(personRepository.findOrdered().isEmpty());

        // Mock custom methods:
        Mockito.verify(personRepository).findOrdered();
        Mockito.verify(personRepository, Mockito.atLeastOnce()).findById(Mockito.any());
        Mockito.verifyNoMoreInteractions(personRepository);
    }
}
----
