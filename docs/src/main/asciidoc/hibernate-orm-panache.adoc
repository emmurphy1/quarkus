////
This guide is maintained in the main Quarkus repository
and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
////
= Using simplified Hibernate ORM with Panache

include::./attributes.adoc[]
:config-file: application.properties


As a Java developer, you can use Hibernate ORM with Panache to simplify persistence with your Quarkus applications.

.Prerequisites
You have a Quarkus Maven project that uses a Java database connectivy (JDBC) datasource.

* For information about creating a Quarkus Maven project, see <<XREF>>.
* For information about configuring your Quarkus Maven project with a JDBC datasource, see <<XREF>>.

== Hibernate ORM


//adapted from https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html. Module will be reused in Hibernate ORM story.

Coupling Java object-oriented software projects with relational databases for data persistence can be cumbersome and time-consuming. Development costs are significantly higher due to a paradigm mismatch between how data is represented in objects versus relational databases. Hibernate is an Object/Relational Mapping (ORM) solution for Java environments that facilitates mapping data to and from an object model representation to a relational data model representation. It an implementation of the Java Persistence API (JPA).

Hibernate not only takes care of the mapping from Java classes to database tables and from Java data types to SQL data types, but also provides data query and retrieval facilities. It can significantly reduce development time otherwise spent with manual data handling in SQL and Java database connectivy (JDBC). Hibernateâ€™s design goal is to relieve you of most common data persistence-related programming tasks by eliminating the need for manual, hand-crafted data processing using SQL and JDBC.

The JPA `@entity` annotation is at the heart of Hibernate ORM. When applied to a Java class, it maps the class to a specific database table. The fields in the class map to database columns. Each instance of the class represents a database row.

== Hibernate ORM with the Quarkus Panache JPA extension

Hibernate ORM is the most widely used JPA implementation. It provides all of the features of an ORM. However, for a simple implementation that use the most common data mappings you can use the Quarkus Panache JPA extension to write more concise code.

The Hibernate ORM with Panache extension contains the following classes:

* `PanacheEntity`
* `PanacheEntityBase`
* `PanacheQuery`
* `PanacheRepository`
* `PanacheRepositoryBase`
* `PanacheEntity`

The Quarkus Panache JPA extension eliminates the following Hiberante ORM issues:

* *Duplicate ID logic*
+
You use the `PanacheEntity` class to create entities. Because the ID is defined automatically in the `PanacheEntity` class, you do not need to define it in your `PanacheEntity` instance. However, you can speciy your own ID in your instance if you prefer.  If you require a custom ID strategy, you can extend the `PanacheEntityBase` class instead.

* *Useless `getter` and `setter` functions*
+
Because Java does not support properties, when you write Java code you must create fields and then generate `getter` and `setter` functions for those fields, even if all you need to do is read or write to the field. With Panache, if you define a field as a public field and then read or write to that field, Panache generates the required `getter` and `setter` functions. In addition, you can write other accessors as required.
* *Entity definitions split from operations*
+
In the traditional Java EE model, you put the the entity definition in one class, the model, and the operations you can perform on the model in another class, the data access object (DAO) or repository. The Panache active record method enables you to create the entity definition and the repository in the same class.

* *Verbose Hibernate queries*
+
Panache provides Hibernate Query Language (HQL) shortcuts to simplify your queries. You do not write parts of the query that you do not need.



//COMMENT: Does the user need  to know about the panache and package-info classes?


=== Using the Panache active record pattern


When you use Hiberate ORM, you must create two classes that separates the state and its operations even though you would never that for regular Java objects where state and methods are in the same class. In addition to requiring two classes, Hibernate ORM requires you to  inject the repository where you need to perform entity operations, which breaks your edit flow and requires you to get out of the code that you are  writing to set up an injection point before coming back to use it.

You can use the Panache active record pattern with the `PanacheEntity` to keep the model and the repository together.


.Prerequisites
You have a Quarkus Maven project that uses a Java database connectivy (JDBC) datasource.

* For information about creating a Quarkus Maven project, see <<XREF>>.
* For information about configuring your Quarkus Maven project with a JDBC datasource, see <<XREF>>.

.Procedure.

. Add the Panache JPA extension dependency to your Quarkus project `pom.xml` file:
+
[source,java]
----
<dependencies>
    <dependency>
        <groupId>io.quarkus</groupId>
        <artifactId>quarkus-hibernate-orm-panache</artifactId>
    </dependency>
----

+
. To define an entity, create a class that extends the `PanacheEntity` class, annotate it with `@Entity`, and add your
columns as public fields. The following example creates and annotates the `Person` clas:
+
[source,java]
----
@Entity
public class Person extends PanacheEntity {
    public String name;
    public LocalDate birth;
    public Status status;
}
----
+
. Optional: To specify that field not persist, use the `@Transient` annotation. The following example annotates the `Status` field with `@Transient`.
+
[source,java]
----
@Entity
public class Person extends PanacheEntity {
    public String name;
    public LocalDate birth;

    @Transient
    public Status status;
}
----
. Add any additional accessors. The following example adds an accessor that returns `name` as uppercase in the model and an accessor that stores all names in lowercase in the database.
//COMMENT: Is there a different between 'in the model' and 'in the database'?
+
[source,java]
----
@Entity
public class Person extends PanacheEntity {
    public String name;
    public LocalDate birth;

    @Transient
    public Status status;
}
    public String getName(){
        return name.toUpperCase();
    }
    public void setName(String name){
        this.name = name.toLowerCase();
    }
}
----
+
In this example, when users access `person.name` they call the `getName()` accessor and when they call the `setName()` accessor...
//what does this do? And do they call setName?
This enables correct encapsulation at runtime because all field calls are replaced with the corresponding `getter` and `setter` calls.
. Add custom queries to your entities as static methods inside the entities themselves so queries are co-located with the object they operate on. The following example adds three custom queries, `findByName`, `findAlive`, and `deleteStefs`:
+
[source,java]
----
@Entity
public class Person extends PanacheEntity {
    public String name;
    public LocalDate birth;
    public Status status;

    public static Person findByName(String name){
        return find("name", name).firstResult();
    }

    public static List<Person> findAlive(){
        return list("status", Status.Alive);
    }

    public static void deleteStefs(){
        delete("name", "Stef");
    }
}
----


=== Using the Panache repository pattern
Panache enables you to create entities that contain the model and repository in a single class. However, if you prefer to create a separate class for the model and a separate class for the repository and still have the other benefits of Panache, for example having the `getters` and `setter` automatically generate, you can use the repository pattern.

.Prerequisites
You have a Quarkus Maven project that uses a Java database connectivy (JDBC) datasource.

* For information about creating a Quarkus Maven project, see <<XREF>>.
* For information about configuring your Quarkus Maven project with a JDBC datasource, see <<XREF>>.

.Procedure.


. Add the Panache JPA extension dependency to your Quarkus project `pom.xml` file:
+
//COMMENT: In the recording you say we can still use PanacheEntity with the repsoitory pattern but this examnple does not use PanacheEntity, right?
+
[source,java]
----
<dependencies>
    <dependency>
        <groupId>io.quarkus</groupId>
        <artifactId>quarkus-hibernate-orm-panache</artifactId>
    </dependency>
----

. Define entities as JPA entities. The following example defines the `Person` class as a JPA entity.
+
[source,java]
----
@Entity
public class Person {
    @Id @GeneratedValue private Long id;
    private String name;
    private LocalDate birth;
    private Status status;

    public Long getId(){
        return id;
    }
    public void setId(Long id){
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public LocalDate getBirth() {
        return birth;
    }
    public void setBirth(LocalDate birth) {
        this.birth = birth;
    }
    public Status getStatus() {
        return status;
    }
    public void setStatus(Status status) {
        this.status = status;
    }
}
----
. Define your repository and add instance methods. The following example defines the `PersonRepository` :
+
[source,java]
----
@ApplicationScoped
public class PersonRepository implements PanacheRepository<Person> {

   public Person findByName(String name){
       return find("name", name).firstResult();
   }

   public List<Person> findAlive(){
       return list("status", Status.Alive);
   }

   public void deleteStefs(){
       delete("name", "Stef");
  }
}
----

+
. Add the following code to the REST endpoint where you want to use entity operations so that the operations that are defined in `PanacheEntityBase` are available:
+
[source,java]
----
@Inject
PersonRepository personRepository;

@GET
public long count(){
    return personRepository.count();
}
----

=== Pananche common operations
This section list common operations that you can use with your entity or entity repository. The active record pattern examples use a `Person` entity created from the `PanacheEntity' class. The repository pattern examples use a regular JPA `Person` entity and the `PersonRepository` created from the
`PanacheRepository` class.

* Create a record (active record pattern and repository pattern):
+
[source,java]
----
Person person = new Person();
person.name = "Stef";
person.birth = LocalDate.of(1910, Month.FEBRUARY, 1);
person.status = Status.Alive;
----

* Persist an entity:
** Active record pattern:
+
[source,java]
----
person.persist(person);
----

** Repository pattern:
+
[source,java]
----
personRepository.persist(person);
----
+
NOTE: After an entity is persisted, you do not need to explicitly save your entity. All changes are automatically persisted on transaction commit.

* Verify that an entity is persisted:
** Active record pattern:
+
[source,java]
----
if(person.isPersistent(person))
----
** Repository pattern:
+
[source,java]
----
if(personRepository.isPersistent(person))
----

* Delete an entity:
** Active record pattern:
+
[source,java]
----
person.delete(person);
----

** Repository pattern:
+
[source,java]
----
personRepository.delete(person);
----

* Retrieve a list of all `Person` entities:
** Active record pattern:
+
[source,java]
----
List<Person> allPersons = person.listAll();
----
** Repository pattern:
+
[source,java]
----
List<Person> allPersons = personRepository.listAll();
----
* Find a specific person by ID:
** Active record pattern:
+
[source,java]
----
person = person.findById(personId);
----
** Repository pattern:
+
[source,java]
----
person = personRepository.findById(personId);
----

* Find a specific person by ID using the `Optional` class:
** Active record pattern:
+
[source,java]
----
Optional<Person> optional = person.findByIdOptional(personId);
person = optional.orElseThrow(() -> new NotFoundException());
----

** Repository pattern:
+
[source,java]
----
Optional<Person> optional = personRepository.findByIdOptional(personId);
person = optional.orElseThrow(() -> new NotFoundException());
----

* Find all living persons:
** Active record pattern:
+
[source,java]
----
List<Person> livingPersons = person.list("status", Status.Alive);
----
** Repsository pattern:
+
[source,java]
----
List<Person> livingPersons = personRepository.list("status", Status.Alive);
----

* Count all persons:
** Active record pattern:
+
[source,java]
----
long countAll = person.count();
----
** Repository pattern:
+
[source,java]
----
long countAll = personRepository.count();
----

* Count all living persons:
** Active record pattern:
+
[source,java]
----
long countAlive = person.count("status", Status.Alive);
----
** Repository pattern:
+
[source,java]
----
long countAlive = personRepository.count("status", Status.Alive);
----

* Delete all living persons:
** Active record pattern:
+
[source,java]
----
person.delete("status", Status.Alive);
----
** Repository pattern:
+
[source,java]
----
personRepository.delete("status", Status.Alive);
----


* Delete all persons:
** Active record pattern:
+
[source,java]
----
person.deleteAll();
----
** Repository pattern:
+
[source,java]
----
personRepository.deleteAll();
----

* Delete by ID:
** Active record pattern:
+
[source,java]
----
boolean deleted = person.deleteById(personId);
----
** repository pattern:
+
[source,java]
----
boolean deleted = personRepository.deleteById(personId);
----

* Set the name of all living persons to Mortal:
** Active record pattern:
+
[source,java]
----
person.update("name = 'Mortal' where status = ?1", Status.Alive);
----
** Repository pattern:
+
[source,java]
----
personRepository.update("name = 'Mortal' where status = ?1", Status.Alive);
----

All `List` methods have equivalent `stream` method, which requires a transaction to work:

[source,java]
----
Stream<Person> persons = personRepository.streamAll();
List<String> namesButEmmanuels = persons
    .map(p -> p.name.toLowerCase() )
    .filter( n -> ! "emmanuel".equals(n) )
    .collect(Collectors.toList());
----




== Hibernate ORM with Panache queries

Hibernate Query Language (HQL) is a query language similar to Structured Query Language (SQL). However, HQL works with persistent objects and properties instead of tables and columns. For more information about HQL, see the "HQL and JPQL" section of the xref:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html[_Hibernate ORM User Guide_].

=== PanacheQuery entity

The `PanacheQuery` entity  abstracts the use of paging, getting the number of results, and operating on `List` or `Stream` methods. You can use the `PanacheQuery` entity  for paging and range-based queries.


Only use `List` and `Stream` methods if your table contains small data sets. For large data
sets, use the `Find` method equivalents, which return a `PanacheQuery` on which you can perform paging.

[WARNING]
====
You cannot mix ranges and pages. If your query uses a range, any methods that depend on having a current page throw an `UnsupportedOperationException` exception. To switch back to paging, use `page(Page)` or `page(int, int)`.
====

.Additional resources
* For a complete list of  `PanacheQuery` methods, see the https://javadoc.io/doc/io.quarkus/quarkus-hibernate-orm-panache/latest/io/quarkus/hibernate/orm/panache/PanacheQuery.html[_PanacheQuery Class_] page.

==== Examples of queries that use paging
These examples show how you can use paging in your Panache queries. The active record pattern examples use a `Person` entity created from the `PanacheEntity' class. The repository pattern examples use a regular JPA `Person` entity and the `PersonRepository` created from the
`PanacheRepository` class.



* Create a query for all living persons:
** Active record pattern:
+
[source,java]
----
PanacheQuery<Person> livingPersons = Person.find("status", Status.Alive);
----
** Repository pattern:
+
[source,java]
----
PanacheQuery<PersonRepository> livingPersons = Person.find("status", Status.Alive);
----


* Make pages have 25 entries per page:
+
[source,java]
----
livingPersons.page(Page.ofSize(25));
----


* Retrieve the first page:
** Active record pattern:
+
[source,java]
----
List<Person> firstPage = livingPersons.list();
----
** Repository pattern:
+
[source,java]
----
List<Person.Repository> firstPage = livingPersons.list();
----

* Retrieve the second page:
** Active record pattern:
+
[source,java]
----
List<Person> secondPage = livingPersons.nextPage().list();
----
** Repository pattern:
+
[source,java]
----
List<PersonRepository> secondPage = livingPersons.nextPage().list();
----

* Retrieve page 7:
** Active record pattern:
+
[source,java]
----
List<Person> page7 = livingPersons.page(Page.of(7, 25)).list();
----
** Repository pattern:
+
[source,java]
----
List<PersonRepository> page7 = livingPersons.page(Page.of(7, 25)).list();
----

* Retrieve the number of pages:
+
[source,java]
----
int numberOfPages = livingPersons.pageCount();
----

* Retrieve the total number of entities returned by this query without paging:
[source,java]
----
int count = livingPersons.count();
----

* Chain methods together:
** Active record pattern:
+
[source,java]
----
return Person.find("status", Status.Alive)
   .page(Page.ofSize(25))
   .nextPage()
   .stream()
----
** Repository pattern:
+
[source,java]
----
return PersonRepository.find("status", Status.Alive)
   .page(Page.ofSize(25))
   .nextPage()
   .stream()
----

==== Examples of queries that use a range of values
These examples show how you can use a range of values in your Panache queries. The active record pattern examples use a `Person` entity created from the `PanacheEntity` class. The repository pattern examples use a regular JPA `Person` entity and the `PersonRepository` created from the
`PanacheRepository` class.


* Create a query for all living persons:
** Active record pattern:
+
[source,java]
----
PanacheQuery<Person> livingPersons = Person.find("status", Status.Alive);
----
** Repository pattern:
+
[source,java]
----
PanacheQuery<PersonRepository> livingPersons = Person.find("status", Status.Alive);
----

* Specify a range from index 0 to index 24 (inclusive):
+
[source,java]
----
livingPersons.range(0, 24);
----

* Specify a range called `firstRange` with the range index 0 to index 24 (inclusive):
** Active record pattern:
+
[source,java]
----
List<Person> firstRange = livingPersons.list();
----
** Repository pattern:
+
[source,java]
----
List<PersonRepository> firstRange = livingPersons.list();
----

* Specify a new range called `secondRange` with the range index 25 to index 49 (inclusive):
** Active record pattern:
+
[source,java]
----
List<Person> secondRange = livingPersons.range(25, 49).list();
----

** Repository pattern:
+
[source,java]
----
List<PersonRepository> secondRange = livingPersons.range(25, 49).list();
----


=== Simplified Hibernate ORM with Panache queries
You can use HQL to write queries for Hibernate ORM with Panache entities, as shown in the following example:

[source,java]
----
Order.find("select distinct o from Order o left join fetch o.lineItems");
Order.update("update from Person set name = 'Mortal' where status = ?", Status.Alive);
----

However, Hibernate ORM with Panache provides several HQL short cuts.

.FROM
In most cases, HQL `SELECT` statements are immediately followed by the `FROM` clause, for example `SELECT name FROM _ENTITY_NAME_`, where `_ENTITY_NAME_` is the name of a Java entity. However, if you do not include `FROM` in your HQL `SELECT` statement, Panache adds `FROM` in the following cases:

[cols="30%,70%" options="header"]

|===
h|User entry
h|Expanded entry

|`ORDER BY`
|`FROM _ENTITY_NAME_ ORDER BY`

| A single column name and a single parameter `_SINGLE_COLUMN_NAME_`
|`FROM _ENTITY_NAME_ WHERE  _SINGLE_COLUMN_NAME_  =?`


| A query string (_QUERY_STRING_)
| `FROM _ENTITY_NAME_ WHERE  _QUERY_STRING_`


|===


.UPDATE

If you do not include `UPDATE` in your HQL `SELECT` statement, Panache adds `UPDATE` in the following cases:

[cols="30%,70%" options="header"]

|===
h|User entry
h|Expanded entry

|`FROM _ENTITY_NAME_`
|`UPDATE FROM _ENTITY_NAME_`

| `set? _SINGLE_COLUMN_NAME_`, where  `_SINGLE_COLUMN_NAME_` is a single column name and a single parameter
| `UPDATE FROM _ENTITY_NAME_ set _SINGLE_COLUMN_NAME_ =?`


| `set? _QUERY_STRING_`, where  `_QUERY_STRING_`is a query string
| `UPDATE FROM _ENTITY_NAME_ set _QUERY_STRING_`

|===

== Named queries

A named query is a statically defined query with an unchangeable query string annoated with Hibernate ORM `@NamedQuery` annotation. With Panache, you can reference a named query from the `find` method. For a named query to work within the context of Panache, it must be defined inside of a `PanacheEntity` class or a `PanacheRepository` class or a super class of one of these classes.

.Prerequisites
* A `PanacheEntity` entity or a `PanacheRepository` entity class exists.

.Procedure

. Add the `@NamedQuery` annotation to a Panache entity.
. In the `find` method, prefix the named query in the `#`.
+
The following example creates the `Person.getByName` and uses it in the `find` method:
+
[source,java]
----
@Entity
@NamedQuery(name = "Person.getByName", query = "from Person where name = :name")
public class Person extends PanacheEntity {
    public String name;
    public LocalDate birth;
    public Status status;

    public static Person findByName(String name){
        return find("#Person.getByName", name).firstResult();
    }
}
----

=== Query parameters

You can pass query parameters by using 1-based indexing, by creating a map, or by creating an instance of the `Parameter` class. Every query operation accepts passing parameters by index (`Object...`), or by name (`Map<String,Object>` or `Parameters`).

[source,java]
----
Person.find("name = ?1 and status = ?2", "stef", Status.Alive);
----

Or by name using a `Map`:

[source,java]
----
Map<String, Object> params = new HashMap<>();
params.put("name", "stef");
params.put("status", Status.Alive);
Person.find("name = :name and status = :status", params);
----

Or using the convenience class `Parameters` either as is or to build a `Map`:

[source,java]
----
// generate a Map
Person.find("name = :name and status = :status",
         Parameters.with("name", "stef").and("status", Status.Alive).map());

// use it as-is
Person.find("name = :name and status = :status",
         Parameters.with("name", "stef").and("status", Status.Alive));
----




=== Sorting

The following examples demonstrate different ways to sort.

* Methods that accept a query string also accept the following simplified query form:
+
[source,java]
----
List<Person> persons = Person.list("order by name,birth");
----

* Methods that accept a query string accept an optional `Sort` parameter, which enables you to abstract your sorting:
** Sort example 1
+
[source,java]
----
List<Person> persons = Person.list(Sort.by("name").and("birth"));
----
** Sort example 2
+

[source,java]
----
List<Person> persons = Person.list("status", Sort.by("name").and("birth"), Status.Alive);
----

The `Sort` class has many methods for adding columns and specifying sort direction.
//Is sort class correct?




== Transactions

Make sure to wrap methods that modify your database, for example `entity.persist()), within a transaction. Marking a
CDI bean method with the `@Transactional` annotation will do that for you and make that method a transaction boundary. We recommend doing
so at your application entry point boundaries such as your REST endpoint controllers.

JPA batches changes you make to your entities and sends changes (it's called flush) at the end of the transaction or before a query.
This is usually a good thing because it is more efficient.
But if you want to check optimistic locking failures, do object validation right away or generally want to get immediate feedback, you can force the flush operation by calling `entity.flush()` or even use `entity.persistAndFlush()` to make it a single method call. This will allow you to catch any `PersistenceException` that could occur when JPA send those changes to the database.
Remember, this is less efficient so don't abuse it.
And your transaction still has to be committed.

Here is an example of the usage of the flush method to allow making a specific action in case of `PersistenceException`:
[source,java]
----
@Transactional
public void create(Parameter parameter){
    try {
        //Here I use the persistAndFlush() shorthand method on a Panache repository to persist to database then flush the changes.
        return parameterRepository.persistAndFlush(parameter);
    }
    catch(PersistenceException pe){
        LOG.error("Unable to create the parameter", pe);
        //in case of error, I save it to disk
        diskPersister.save(parameter);
    }
}
----

== Panache lock management

Panache provides direct support for database locking with your entity or repository, using `findById(Object, LockModeType)` or `find().withLock(LockModeType)`. The following examples use  the active record pattern and the `Person` class. You can apply the same method with repositories.

.Locking using the `findById()` method

[source,java]
----
public class PersonEndpoint {

    @GET
    @Transactional
    public Person findByIdForUpdate(Long id){
        Person p = Person.findById(id, LockModeType.PESSIMISTIC_WRITE);
        //do something useful, the lock will be released when the transaction ends.
        return person;
    }

}
----

.Locking in a `find()` method

[source,java]
----
public class PersonEndpoint {

    @GET
    @Transactional
    public Person findByNameForUpdate(String name){
        Person p = Person.find("name", name).withLock(LockModeType.PESSIMISTIC_WRITE).findOne();
        //do something useful, the lock will be released when the transaction ends.
        return person;
    }

}
----

NOTE: Locks are released when the transaction ends, so the method that invokes the lock query must be annotated with the `@Transactional` annotation.

== Custom IDs

One of the advantages of Panache is that IDs are set automatically in the `PanacheEntityBase` and  `PanacheEntityRepositoryBase` classes. If you can to , you can specify your own ID strategy by extending the `PanacheEntityBase` or `PanacheEntityRepositoryBase` class, depending on the entity method you are using.


.Procedure

. Create a class that extends `PanacheEntityBase`.
. Declare the ID you want as a public field. The following example extends the  `PanacheEntityBase` by creating the `Person` class.
+
[source,java]
----
@Entity
public class Person extends PanacheEntityBase {

    @Id
    @SequenceGenerator(
            name = "personSequence",
            sequenceName = "person_id_seq",
            allocationSize = 1,
            initialValue = 4)
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "personSequence")
    public Integer id;

    //...
}
----

NOTE: If you are using repositories, extend the `PanacheRepositoryBase` class instead of the `PanacheRepository` class
and specify your ID type as an extra type parameter:

[source,java]
----
@ApplicationScoped
public class PersonRepository implements PanacheRepositoryBase<Person,Integer> {
    //...
}
----



== Defining entities in external projects or JAR files
//Added content from https://quarkus.io/guides/cdi-reference#how-to-generate-a-jandex-index. This module could be shared.

Hibernate ORM with Panache relies on Java `bytecode` enhancements that are added to your entities at compile time. If you define your entities in the project where you build your Quarkus application, the  `bytecode` enhancements are added correctly. If the entities come from external projects or JAR files, use Jandex to index your JAR file to ensure that it is treated like a Quarkus application library. Doing this enables Quarkus to index and enhance your entities as if they were inside the current project.

.Prerequisites
* A Quarkus Maven project that uses the Hibernate ORM with Panache extension is available.

.Procedure
To generate the Jandex index, use one of the following methods:

* Add the following dependency to your project's `pom.xml` file:
+
[source,xml]
----
<build>
  <plugins>
    <plugin>
      <groupId>org.jboss.jandex</groupId>
      <artifactId>jandex-maven-plugin</artifactId>
      <version>1.0.7</version>
      <executions>
        <execution>
          <id>make-index</id>
          <goals>
            <goal>jandex</goal>
          </goals>
        </execution>
      </executions>
    </plugin>
  </plugins>
</build>
----

* Add `quarkus.index-dependency` entries to your `application.properties` file, where `_NAME_` is the name of the dependency,`_GROUP_ID_` is the group ID for that dependency, `_ARTIFACT_ID` is the artifact ID for that dependency, and `_CLASSIFIER_` is the dependency classifier:
+
[source,properties]
----
quarkus.index-dependency._NAME_.group-id=_GROUP_ID_
quarkus.index-dependency._NAME_.artifact-id=<_ARTIFACT-ID_
quarkus.index-dependency._NAME_.classifier=_CLASSIFIER_
----
+
NOTE: The `quarkus.index-dependency._NAME_.classifier=_CLASSIFIER_` line is optional.
+
For example, the following entries ensure that the `org.acme:acme-api` dependency is indexed:
+
[source,properties]
----
quarkus.index-dependency.acme.group-id=org.acme
quarkus.index-dependency.acme.artifact-id=acme-api
----










--------------------------------------------------

== Setting up and configuring Hibernate ORM
//Added and adapted from Hibernate ORM guide

NOTE: To see the completed example, clone the https://github.com/quarkusio/quarkus-quickstarts.git[Quarkus Quickstarts] Git repository or download the https://github.com/quarkusio/quarkus-quickstarts/archive/master.zip[Quarkus Quickstarts] archive. The solution is located in the `hibernate-orm-panache-quickstart` directory.

//When using Hibernate ORM in Quarkus, you don't need to have a `persistence.xml` resource to configure it. Using such a classic configuration file is an option, but unnecessary unless you have specific advanced needs;
so we'll see first how Hibernate ORM can be configured without a `persistence.xml` resource.

In Quarkus, you just need to:

//* add your configuration settings in `{config-file}`
//* annotate your entities with `@Entity` and any other mapping annotation as usual

//Other configuration needs have been automated: Quarkus will make some opinionated choices and educated guesses.

Add the following dependencies to your project:

* The Panache JPA extension: `io.quarkus:quarkus-hibernate-orm-panache`
* Your Java database connectivity (JDBC) driver extension. Quarkus support the following JDBC driver extensions:
+
* `quarkus-jdbc-derby` for link:https://db.apache.org/derby/[Apache Derby]
* `quarkus-jdbc-h2` for link:https://www.h2database.com/html/main.html[H2]
* `quarkus-jdbc-mariadb` for link:https://mariadb.com/[MariaDB]
* `quarkus-jdbc-mssql` for link:https://www.microsoft.com/en-gb/sql-server/[Microsoft SQL Server]
* `quarkus-jdbc-mysql` for link:https://www.mysql.com/[MySQL]
* `quarkus-jdbc-postgresql` for link:https://www.postgresql.org/[PostgreSQL]


  The following example shows how to add the Panache JPA extension and the PostgreSQL JDBC driver:
  +
  [source,xml]
  ----
  <dependencies>
      <!-- Hibernate ORM specific dependencies -->
      <dependency>
          <groupId>io.quarkus</groupId>
          <artifactId>quarkus-hibernate-orm-panache</artifactId>
      </dependency>

      <!-- JDBC driver dependencies -->
      <dependency>
          <groupId>io.quarkus</groupId>
          <artifactId>quarkus-jdbc-postgresql</artifactId>
      </dependency>
  </dependencies>
  ----

.Add the relevant configuration properties to the `application.properties` file.
+
[source,properties]
--
# datasource configuration
quarkus.datasource.url = jdbc:postgresql://localhost:5432/hibernate_db
quarkus.datasource.driver = org.postgresql.Driver
quarkus.datasource.username = hibernate
quarkus.datasource.password = hibernate

# drop and create the database at startup (use `update` to only update the schema)
quarkus.hibernate-orm.database.generation=drop-and-create
--

NOTE: These configuration properties are different from a Hibernate ORM configuration file: these drive Quarkus configuration properties,
which often will map to Hibernate configuration properties but could have different names and don't necessarily map 1:1 to each other.


See the  <<hibernate-configuration-properties, Hibernate ORM configuration properties>> section for the list of properties you can set in `{config-file}`.

An `EntityManagerFactory` will be created based on the Quarkus `datasource` configuration as long as the Hibernate ORM extension is listed among your project dependencies.

The dialect will be selected based on the JDBC driver - unless you set one explicitly.
